http://c.biancheng.net/view/735.html


shell 在系统中的位置


shell 的解析器


shell 可执行脚本的编写规范

#!/bin/bash    #!约定指定解析器 /bin/bash

引用变量使用$

运行 Shell 脚本  开启了新进程
更改权限为可执行
 chmod +x ./test.sh  #给脚本添加执行权限
 ./test.sh           #执行脚本文件 如果不写./会系统变量目录下查找 会not find

 可以使用 /bin/bash test.sh  #使用Bash的绝对路径

 可以使用$$特殊变量 pid验证

当前进程中运行 Shell 脚本
  source 是 Shell 内置命令的一种，它会读取脚本文件中的代码，并依次执行所有语句。
  你也可以理解为，source 命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。
  source filename

变量
在 Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。
定义变量
variable=value
variable='value'
variable="value"
如果 value 不包含任何空白符（例如空格、Tab 缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来。

变量使用 $ ${}
以单引号' '包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出
以双引号" "包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。

命令的结果赋值给变量
variable=`command`
variable=$(command)
一种方式把命令用反引号` `（位于 Esc 键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；
第二种方式把命令用$()包围起来，区分更加明显，所以推荐使用这种方式。

只读变量
readonly   变量

删除变量 unset

Shell变量的作用域：Shell全局变量、环境变量和局部变量

Shell 变量的作用域可以分为三种：
a)有的变量可以在当前 Shell 会话中使用，这叫做全局变量（global variable）；
 所谓全局变量，就是指变量在当前的整个 Shell 会话中都有效。每个 Shell 会话都有自己的作用域，彼此之间互不影响。在 Shell 中定义的变量，默认就是全局变量。
 打开两个 Shell，或使用两个终端远程连接到服务器（SSH）验证
 需要强调的是，全局变量的作用范围是当前的 Shell 会话，而不是当前的 Shell 脚本文件，它们是不同的概念。
 打开一个 Shell 窗口就创建了一个 Shell 会话，打开多个 Shell 窗口就创建了多个 Shell 会话，每个 Shell 会话都是独立的进程，拥有不同的进程 ID。
 在一个 Shell 会话中，可以执行多个 Shell 脚本文件，此时全局变量在这些脚本文件中都有效。
b)有的变量只能在函数内部使用，这叫做局部变量（local variable）；
  Shell 也支持自定义函数，但是 Shell 函数和 C/C++、Java 等其他编程语言函数的一个不同点就是：
   在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果。
   要想变量的作用域仅限于函数内部，那么可以在定义时加上local命令，此时该变量就成了局部变量
c)而有的变量还可以在其它 Shell 中使用，这叫做环境变量（environment variable）
  全局变量只在当前 Shell 会话中有效，如果使用export命令将它导出，那么它就在所有的子 Shell 中也有效了，这称为“环境变量”。
  环境变量被创建时所处的 Shell 被称为父 Shell，如果在父 Shell 中再创建一个 Shell，则该 Shell 被称作子 Shell。
  通过exit命令可以一层一层地退出 Shell。
  export a 或 export a=2
  在一个 Shell 中创建子 Shell 最简单的方式是运行 bash 命令
  通过export命令导出的环境变量是临时的，关闭 Shell 会话后它就销毁了。所以，这种环境变量也只是在局部范围内起作用，并不影响所有 Shell。
d)所有shell可以使用的环境变量
  如果想让环境变量在所有 Shell 中都有效，并且能够永久保存，在关闭 Shell 后也不丢失，那么就需要把环境变量写入启动文件

Shell位置参数（命令行参数）
$n 接受参数
在调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。
换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用$n的形式接收
这种通过$n的形式来接收的参数，在 Shell 中称为位置参数。
如果参数个数太多，达到或者超过了 10 个，那么就得用${n}的形式来接收了，例如 ${10}、${23}。

特殊参数除了 $n，Shell 中还有 $#、$*、$@、$?、$$ 几个特殊参数
$0	当前脚本的文件名。
$n（n≥1）	传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。
$#	传递给脚本或函数的参数个数。
$*	传递给脚本或函数的所有参数。
$@	传递给脚本或函数的所有参数。当被双引号" "包含时，$@ 与 $* 稍有不同，我们将在《Shell $*和$@的区别》一节中详细讲解。
$?	上个命令的退出状态，或函数的返回值，我们将在《Shell $?》一节中详细讲解。
$$	当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。

当 $* 和 $@ 不被双引号" "包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。

但是当它们被双引号" "包含时，就会有区别了：
"$*"会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。
"$@"仍然将每个参数都看作一份数据，彼此之间是独立的。

比如传递了 5 个参数，那么对于"$*"来说，这 5 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于"$@"来说，这 5 个参数是相互独立的，它们是 5 份数据。

如果使用 echo 直接输出"$*"和"$@"做对比，是看不出区别的；但如果使用 for 循环来逐个输出数据，立即就能看出区别来。


$? 是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。

所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1，这和C语言的 main() 函数是类似的。



Shell 数组的定义  （）
${array_name[index]}
使用@或*可以获取数组中的所有元素，例如：
${nums[*]}
${nums[@]}




shell 交互使用 expect的包

查看安装 rpm -qa | grep expect






